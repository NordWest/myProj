#ifndef MB_H
#define MB_H


extern "C"
{



bool ssleg(const double* a, double *const x, const double* b, int size);
/*
решение системы линейных алгебраических уравнений методом Гаусса
a - массив коэффициентов перед неизвестными,
b - коэффициенты правых частей,
x - массив, в который помещаются результаты,
size - число уравнений и неизвестных.
функция возвращает true, если решение выполнено успешно, и - false в противном случае.
*/


bool invgj(double *const inv, const double* a, int size);
        /*
        обращение матрицы методом Гаусса-Жордана
        a - указатель на массив элементов матрицы,
        inv - указатель на массив, в который должен быть записан результат
        size - размер матрцы.
        функция возвращает true, если обращение выполнено успешно, и - false в противном случае.
        */


bool mvprod(double *const r, const double* m, const double* v, int w, int h);
/*
умножение матрицы  m на вектор v.
r - указатель на массив элементов результирующей матрицы,
m - указатель на массив элементов исходной матрицы
v - указатель на массив элементов вектора размером w
w,h - размеры матрцы по горизонтали и вертикали.
функция возвращает true
*/


bool mmprod(double *const r, const double* ml, const double* mr, int wl, int hl, int wr, int hr);
/*
умножение матрицы  ml(размеры матрицы wl X hl) на матрицу mr (размеры матрицы wr X hr).
r - указатель на массив элементов результирующей матрицы размером wr X hl,
ml - указатель на массив элементов матрицы, стоящей слева,
mr - указатель на массив элементов матрицы, стоящей справа,
функция возвращает true при успешном выполнении операции и false в случае wl!=hr, когда умножение невозможно
*/


void transpose(double *const r, const double* m, int w, int h);
/*
транспонирование матрицы m (размеры матрицы w X h).
r - указатель на массив элементов результирующей матрицы размером h X w,
m - указатель на массив элементов исходной матрицы,
*/


bool mdiagprod(double *const r, const double* m, const double* d, int w, int h);
/*
умножение матрицы  m на диагональную матрицу d.
r - указатель на массив элементов результирующей матрицы,
m - указатель на массив элементов исходной матрицы
d - указатель на одномерный массив диагональных элементов матрицы d,
w,h - размеры матрцы m по горизонтали и вертикали.
функция возвращает true
*/



void slsm(int w, int h, double *const z, const double* c, const double* L, const double* W = 0);
/*
Метод наименьших квадратов. ? ешаем систему вида L = с*z
Эта функция позволяет быстро вычислить вектор неизвестных (z), чтобы сэкономить время и ресурсы.
Ковариационная матрица, ошибка единицы веса и ошибки неизвестных не вычисляются,
L - указатель на массив элементов, представляющий вектор данных.
W - указатель на массив элементов, представляющий весовую диагональную матрицу.
Для экономии времени и ресурсов диагональная матрица хранится как одномерный массив диагональных элементов.
По умолчанию этот указатель равен 0 (то есть если веса не нужны)
w,h - размеры матрцы плана (с) по горизонтали и вертикали. Одновременно w - число неизвестных, h - число условных уравнений
z - вектор оценок параметров модели (указатель на одномерный массив, в который выводится результат)
*/


void hclsm(int w, int h, double *const z, const double* c, const double* L, double& uwe, double *const D, const double* W,
           int q, const double* E, const double* t);

/*
Метод наименьших квадратов c "жесткими" условиями.
? ешаем систему вида L = с*z + r, r - это вектор невязок с нулевым матожиданием
"жесткие условия" вводятся как модель вида E*z = t (строгое равенство). q - размер матрицы Е по вертикали.
L - указатель на массив элементов, представляющий вектор данных.
W - указатель на массив элементов, представляющий весовую диагональную матрицу.
Для экономии времени и ресурсов диагональная матрица хранится как одномерный массив диагональных элементов.
По умолчанию этот указатqDebug() << QString("\nt: %1 - %2\nyrSpan: %3").arg(t0).arg(t1).arg(timeSpan);ель равен 0 (то есть если веса не нужны)
w,h - размеры матрцы плана (с) m по горизонтали и вертикали. Одновременно w - число неизвестных, h - число условных уравнений
uwe - указатель на переменную, в которую выводится значение ошибки единицы веса в квадрате
z - вектор оценок параметров модели (указатель на одномерный массив, в который выводится результат)
D - указатель на массив элементов ковариационной матрицы
*/



void lsm(int w, int h, double *const z, const double* c, const double* L, double& uwe, double *const D, const double* W = 0);

/*
Метод наименьших квадратов c выводом ковариационной матрицы. ? ешаем систему вида L = с*z + r, r - это вектор невязок с нулевым матожиданием
L - указатель на массив элементов, представляющий вектор данных.
W - указатель на массив элементов, представляющий весовую диагональную матрицу.
Для экономии времени и ресурсов диагональная матрица хранится как одномерный массив диагональных элементов.
По умолчанию этот указатель равен 0 (то есть если веса не нужны)
w,h - размеры матрцы плана (с) m по горизонтали и вертикали. Одновременно w - число неизвестных, h - число условных уравнений
uwe - указатель на переменную, в которую выводится значение ошибки единицы веса в квадрате
z - вектор оценок параметров модели (указатель на одномерный массив, в который выводится результат)
D - указатель на массив элементов ковариационной матрицы
*/


void iLSM(int w, int h, double maxdiv, int *const exclind, double *const z, const double* c, const double* L, double& uwe, double *const D, double fl, int& rn, const double* W =0);

/*
Метод наименьших квадратов c выводом ковариационной матрицы. ? ешаем систему вида L = с*z
L - указатель на массив элементов, представляющий вектор данных.
W - указатель на массив элементов, представляющий весовую диагональную матрицу.
Для экономии времени и ресурсов диагональная матрица хранится как одномерный массив диагональных элементов.
По умолчанию этот указатель равен 0 (то есть если веса не нужны)
w,h - размеры матрцы плана (с) m по горизонтали и вертикали. Одновременно w - число неизвестных, h - число условных уравнений
uwe - указатель на переменную, в которую выводится значение ошибки единицы веса в квадрате
z - вектор оценок параметров модели (указатель на одномерный массив, в который выводится результат)
D - указатель на массив элементов ковариационной матрицы
maxdiv - максимальное значение невязки условыных уравнений, уравнения с невязкой, большей maxdiv исключаются из решений
exclind - одномерный массив, содержит номер уравнения, если оно использовалось и -1, если оно исключено
fl - флаг, маркирующий способ отбраковки:
если fl>0, то на первой итерации вычисляется ошибка единицы веса и перевычисляется maxdiv = fl*'ошибку единицы веса'.
Это позволяет применять критерии типа "3-сигма"
если fl<=0, то для отбраковки используется maxdiv, заданный при вызове функции
rn - по завершении содержит число уравнений, которое реально использовалось.
*/

void iterLSM(int w, int h, double *const z, const double* c, const double* L, double& uwe, double *const D, double fl, int& rn, const double* W);
void mlsm(int w, int h, double *const z, const double* c, const double* L, double& uwe, double *const D, const double* W);

void centerofmass(double *const cm, const double* fd, int rho);


void getFWHM(double *const fwhm, const double* fd, int rho, double blevel);


double getpsf(const double* p, double x, double y, int model);
//функция выдает значение PSF для вектора параметров p и пиксельных координат x,y.
// model - модель PSF (0 - профиль Лоренца, 1 - профиль Моффата, 2 - профиль Гаусса со степенью).


double getpdpsf(const double* p, double x, double y, int model, int nv);
/*функция выдает значение частной производной PSF для вектора параметров p и пиксельных координат x,y.
model - модель PSF (0 - профиль Лоренца, 1 - профиль Моффата, 2 - профиль Гаусса со степенью).
nv - номер переменной для которой вычисляется значение часной производной.
p[0] = Xo - пиксельные координаты фотоцентра изображения звездообразного объекта
p[1] = Yo
p[2] = Jo - уровень фона. Не вычисляется в данной функции, вычисляется вне функции и передается во входном массиве p
p[3]= Jmax - уровень максимума psf
p[4] = A, p[5] = B, p[6] = C - параметры, описывающие ширину профиля и его ориентировку и эллептичность
p[7] = delta - степень psf
*/

double lorenzian(double *const p, double x, double y);
double Jlorenzian(double *const p, double x, double y,int n);
bool lorenzianFit(double *const p, const double* fd,  int rho, int nit, double minstep);

bool psffit(double *const p, const double* fd, int rho, int model, int nit, double kappa, double lambda, double regk, int& it, int ipfl);
/*
функция реализует вычисления по алгоритму Левенберга-Марквардта для определения параметров psf
p - вектор параметров (длина массива должна быть равна 21)
p[0] = Xo - пиксельные координаты фотоцентра изображения звездообразного объекта
p[1] = Yo
p[2] = Jo - уровень фона. Не вычисляется в данной функции, вычисляется вне функции и передается во входном массиве p
p[3]= Jmax - уровень максимума psf
p[4] = A, p[5] = B, p[6] = C - параметры, описывающие ширину профиля и его ориентировку и эллептичность
p[7] = delta - степень psf

fd - массив отсчетов в пределах апертуры.
model - модель PSF (0 - профиль Лоренца, 1 - профиль Моффата, 2 - профиль Гаусса со степенью)
rho - радиус апертуры
nit - максимально-возможное число успешных итераций (опыт подсказывает, что лучше ограничиться значением в пределах 20 -50)
kappa - критерий завершения вычислений, это отношение длины вектора поправок к корню из дисперсии последних шести векторов поправок. Это своеобразный критерий сходимости, возможно не самый лучший.? азумные значения уместно брать в пределах от 0.01 до 0.1. То есть i-тая поправка лежит глубоко в пределах дисперсии последних поправок.

lambda - регуляризующий коэффициент. Обычно на входе составляет 0.001 - 0.01. Показывает какая доля от каждого диагонального элемента Гессиана должна к нему прибавляться.
regk - коэффициент для управления значением lambda. При успешной итерации lambda уменьшается в соответствие с regk в степени числа неуспешных итераций (успешная итерация - итерация, при которой уменьшается сумма квадратов невязок).
В случае неуспешной итерации lambda умножается на regk.

it - можно передать 0-ое значение. После выхода из функции it будет содержать число успешных итераций

ipfl - флаг задающий способ вычисления начальных значений Xo,Yo. Если ipfl = 0 - по максимальному пикселю (для ПЗС - это лучше), ipfl = 1 - по центру масс (предполагается, что это лучше подходит для сканированных изображений фотопластинок)

На выходе в массиве p содержатся: элементы 0 - 7 - значения параметров профиля как описано выше.

p[8] = ошибка единицы веса для последней итерации
элементы 9 - 16 - оценки СКО соответствующих параметров 0-7
p[17] - значение десятичного логарифма интеграла psf над фоном в пределах апертуры
p[18] - значение десятичного логарифма суммы отсчетов на пикселях в пределах апертуры
Последние два значения характеризуют поток излучения от измеряемого объекта
p[19] - число пикселей в пределах апертуры
p[20] - общее число итераций (и успешных и неуспешных)
*/


bool ringfit(double *const p, const double* fd, int rho2);

void subtractSurface(const double* p, double *const fd, double bp, int rho);

double meanRingValue(const double* fd, int rho2);

int Cubic(double *x,double a,double b,double c);

void angletr(double X0, double Y0, double X1, double Y1,double X2, double Y2, double& angle, double& ratio);

bool matchstars(int *tangNum,const  double *ksi,const  double *eta, int *pixNum,const  double *X,const  double *Y, int Nstang, int Nspix, double err, double eAng, double eRatio, int matchN);


}

#endif // MB_H
