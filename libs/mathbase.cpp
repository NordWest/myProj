#include "math.h"
#include "mathbase.h"

bool ssleg(double* a, double* x, double* b, int size)
{
/*
решение системы линейных алгебраических уравнений методом Гаусса 
a - массив коэффициентов перед неизвестными,
b - коэффициенты правых частей,
x - массив, в который помещаются результаты,
size - число уравнений и неизвестных.
функция возвращает true, если решение выполнено успешно, и - false в противном случае. 
*/
	//////////////////////////////////////////
	//создаем массивы и копируем в них коэффициенты перед неизвестными (A) и правые части (B) 
	double A[size][size];
	for(int i=0; i<size; i++)
		for(int j=0; j<size; j++)
			A[i][j]=a[i*size+j];
	double B[size];
	for(int i=0; i<size; i++) B[i] = b[i];
	/////////////////////////////////////////////
	//
	double tmp;//переменная для хранения промежуточных данных
	//меняем местами строки так, чтобы не было нулевых элементов на главной диагонали
	for(int k=0;k<size;k++)
	{
		if(A[k][k]==0)
		{
			for(int j=0; j<size; j++)
			{
				if(j!=k)
				{
					if((A[j][k]!=0)&&(A[k][j]!=0))
					{
						for(int i=0; i<size; i++){tmp = A[k][i];A[k][i] = A[j][i];A[j][i]=tmp;}
						break;
					}
				}
			}
			
		}
	}
	//////////////////////////////////////////////
	//прямой ход метода Гаусса: приводим матрицу коэффициентов к треугольному виду
	for(int k=0;k<size;k++)
		for(int i=k+1;i<size;i++)
		{
			if(A[k][k]==0)return false;
			tmp = A[i][k]/A[k][k];
			for(int j=k;j<size;j++)A[i][j]-=tmp*A[k][j];
			B[i]-=tmp*B[k];
		}
	/////////////////////////////////////////////
	//обратный ход метода Гаусса: вычисляем неизвестные
	for(int k=size-1;k>=0;k--)
	{
		tmp = B[k];
		for(int i=k;i<size;i++) tmp-=A[k][i]*x[i];
		x[k] = tmp/A[k][k];
	}
	/////////////////////////////////////////////
	return true;
};

bool invgj(double* inv, double* a, int size)
{
	/*
	обращение матрицы методом Гаусса-Жордана 
	a - указатель на массив элементов матрицы,
	inv - указатель на массив, в который должен быть записан результат
	size - размер матрцы.
	функция возвращает true, если обращение выполнено успешно, и - false в противном случае. 
	*/
	//создаем двумерные массивы A(исходная матрица) и INV (единичная матрица) и заполняем их соответствующими элементами
	double A[size][size];
	for(int i=0; i<size; i++)
		for(int j=0; j<size; j++)
			A[i][j]=a[i*size+j];
	double INV[size][size];
	for(int i=0; i<size; i++)
		for(int j=0; j<size; j++)
			if(i==j)INV[i][j] =1; else INV[i][j]=0;
	double tmp;//переменная для хранения промежуточных данных
	//прямой ход 
	for(int k = 0; k<size; k++)
	{
		if(A[k][k]==0)return false;//нулевой элемент на главной диагонали - выходим из подпрограммы и возвращаем false
		tmp = A[k][k];
		//преобразование, необходимое для того, чтобы элемент на главной диагонали был равен 1
		for(int i = 0; i<size; i++)
		{
			A[k][i] = A[k][i]/tmp;
			INV[k][i] = INV[k][i]/tmp;
		}
		//преобразование, приводящее исходную матрицу к верхней треугольной матрице с единицами на главной диагонали
		for(int i = k+1; i<size; i++)
		{
			tmp = A[i][k];
			for(int j = k; j<size; j++)A[i][j]-=A[k][j]*tmp;
			for(int j = 0; j<size; j++)INV[i][j]-=INV[k][j]*tmp;
		}
	}
	//обратный ход (преобразуем элементы матрицы INV так как если бы мы приводили верхнюю треугольную матрицу А к единичной)
	for(int k=size-1;k>=0;k--)
	{
		for(int i=0;i<k;i++) 
			for(int j=0; j<size; j++)
				INV[i][j]-=INV[k][j]*A[i][k];
	}
	//////////////////////////////////////////////////////////
	//записываем результаты для вывода
	for(int i=0; i<size; i++)
		for(int j=0; j<size; j++)
			inv[i*size+j]= INV[i][j];
	return true;
};

bool mvprod(double* r, double* m, double* v, int w, int h)
/*
умножение матрицы  m на вектор v.
r - указатель на массив элементов результирующей матрицы,
m - указатель на массив элементов исходной матрицы
v - указатель на массив элементов вектора размером w
w,h - размеры матрцы по горизонтали и вертикали.
функция возвращает true 
*/
{
	for(int i=0; i<h; i++)
	{
		r[i]=0;
		for(int j=0; j<w; j++) r[i]+=m[i*w+j]*v[j];
	}
	return true;
};

bool mmprod(double* r, double* ml, double* mr, int wl, int hl, int wr, int hr)
/*
умножение матрицы  ml(размеры матрицы wl X hl) на матрицу mr (размеры матрицы wr X hr).
r - указатель на массив элементов результирующей матрицы размером wr X hl,
ml - указатель на массив элементов матрицы, стоящей слева,
mr - указатель на массив элементов матрицы, стоящей справа,
функция возвращает true при успешном выполнении операции и false в случае wl!=hr, когда умножение невозможно
*/
{
	if(wl!=hr) return false;
	////////////////////////////
	for(int i=0; i<hl; i++)
	{
		for(int j=0; j<wr; j++)
		{
			r[i*wr+j] = 0;
			for(int k=0; k<hr; k++)r[i*wr+j]+=ml[i*wl+k]*mr[k*wr+j]; 
		}
	}
	return true;
};

void transpose(double* r, double* m, int w, int h)
/*
транспонирование матрицы m (размеры матрицы w X h).
r - указатель на массив элементов результирующей матрицы размером h X w,
m - указатель на массив элементов исходной матрицы,
*/
{
	for(int i=0; i<h; i++)
		for(int j=0; j<w; j++) r[j*h+i] = m[i*w+j];
};

bool mdiagprod(double* r, double* m, double* d, int w, int h)
/*
умножение матрицы  m на диагональную матрицу d.
r - указатель на массив элементов результирующей матрицы,
m - указатель на массив элементов исходной матрицы
d - указатель на одномерный массив диагональных элементов матрицы d,
w,h - размеры матрцы m по горизонтали и вертикали.
функция возвращает true 
*/
{
	for(int i=0; i<h; i++)
	{
		for(int j=0; j<w; j++) r[i*w+j] = m[i*w+j]*d[j];
	}
	return true;
};

void swapcolumns(double *a, int size, int p, int q)
{
	double buffer[size];
	for(int i=0;i<size;i++){buffer[i] = a[p+i*size]; a[p+i*size] = a[q+i*size];}
	for(int i=0;i<size;i++)a[q+i*size] = buffer[i];
};

void swaplines(double *a, int size, int p, int q)
{
	double buffer[size];
	for(int i=0;i<size;i++){buffer[i] = a[i+p*size]; a[i+p*size] = a[i+q*size];}
	for(int i=0;i<size;i++)a[i+q*size] = buffer[i];
};

void swapel(double *a, int p, int q)
{
	double el = a[p];
	a[p] = a[q];
	a[q] = el;
};

void slsm(int w, int h, double* z, double* c, double* L, double* W)
{
/*
Метод наименьших квадратов. Решаем систему вида L = с*z
Эта функция позволяет быстро вычислить вектор неизвестных (z), чтобы сэкономит время и ресурсы.
Ковариационная матрица, ошибка единицы веса и ошибки неизвестных не вычисляются,
L - указатель на массив элементов, представляющий вектор данных.
W - указатель на массив элементов, представляющий весовую диагональную матрицу. 
Для экономии времени и ресурсов диагональная матрица хранится как одномерный массив диагональных элементов.
По умолчанию этот указатель равен NULL (то есть если веса не нужны)
w,h - размеры матрцы плана (с) m по горизонтали и вертикали. Одновременно w - число неизвестных, h - число условных уравнений
*/
	double *ww = new double[w*w];//матрица "весов" неизвестных
	double *hh = new double[w];//вектор сt*L, ct - результат транспонирования матрицы с 
	double *x = new double[w];//вектор неизвестных параметров
	////////////////////вычисления ведутся как описано в книге В.С. Губанов Обобщенный метод наименьших квадратов...
	
	double *ct = new double[w*h];
	double *ctw;
	transpose(ct, c, w, h);
	if(W!=NULL)//весовая диагональная матрица задана
	{
		ctw = new double[w*h];
		mdiagprod(ctw, ct, W, h, w);
		mmprod(ww, ctw, c, h, w, w, h);
		mvprod(hh, ctw, L, h, w);
		delete [] ctw;
	}
	else // весовая диагональная матрица не задана
	{
		mmprod(ww, ct, c, h, w, w, h);
		mvprod(hh, ct, L, h, w);
	}
	ssleg(ww, x, hh, w);//решаем систему уравнений методом Гаусса
	for(int i=0;i<w;i++)z[i]=x[i];//выводим результат
	delete [] hh;
	delete [] x;
	delete [] ww;
	delete [] ct;
};

